// Generated by Copilot Jason v2.1 Setup
/**
 * SecurityStatic v2.1 Complete Unit Test Suite
 * Vollst√§ndige Test-Suite mit 27+ deterministischen Tests f√ºr SecurityStatic v2.1
 * 
 * Test-Kategorien: Init, Hashing, HMAC, Answer-Flow, Session, Rate-Limiting, Utilities, Integration
 * Features: Deterministic TEST_MODE, Reproducible Hashes, Complete Coverage
 * Framework: Vitest v3.2.4
 * 
 * @version 2.1.1
 * @author Copilot Jason v2.1 Setup
 * @date 2025-11-13
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';

// ===== DETERMINISTIC TEST MODE CONFIGURATION =====
const TEST_MODE = true;
const DETERMINISTIC_SALT = 'TEST_SALT_2024_V2';

// Enhanced Browser Environment Mock for Node.js Testing
global.window = {
  crypto: {
    subtle: {
      importKey: vi.fn(),
      deriveBits: vi.fn(),
      digest: vi.fn().mockImplementation(async (algorithm, data) => {
        // Deterministisches Mock f√ºr Tests
        if (TEST_MODE) {
          const input = new Uint8Array(data);
          const hash = Array.from(input).reduce((acc, val) => acc + val, 0);
          return new ArrayBuffer(32).fill(hash % 256);
        }
        return new ArrayBuffer(32);
      }),
      sign: vi.fn().mockImplementation(async (algorithm, key, data) => {
        if (TEST_MODE) {
          const input = new Uint8Array(data);
          const signature = Array.from(input).reduce((acc, val) => acc + val, 0);
          return new ArrayBuffer(32).fill(signature % 256);
        }
        return new ArrayBuffer(32);
      })
    },
    getRandomValues: vi.fn((array) => {
      if (TEST_MODE) {
        // Deterministisches Random f√ºr reproduzierbare Tests
        for (let i = 0; i < array.length; i++) {
          array[i] = (i * 17 + 42) % 256; // Vorhersagbarer Seed
        }
      } else {
        for (let i = 0; i < array.length; i++) {
          array[i] = Math.floor(Math.random() * 256);
        }
      }
      return array;
    })
  },
  top: {},
  self: {},
  location: { 
    hostname: 'localhost',
    href: 'http://localhost:8001/test.html',
    protocol: 'http:',
    port: '8001'
  }
};

// Enhanced Storage Mocks
global.sessionStorage = {
  data: {},
  getItem(key) { return this.data[key] || null; },
  setItem(key, value) { this.data[key] = value; },
  removeItem(key) { delete this.data[key]; },
  clear() { this.data = {}; }
};

global.localStorage = {
  data: {},
  getItem(key) { return this.data[key] || null; },
  setItem(key, value) { this.data[key] = value; },
  removeItem(key) { delete this.data[key]; },
  clear() { this.data = {}; }
};

global.document = {
  addEventListener: vi.fn(),
  querySelectorAll: vi.fn(() => []),
  createElement: vi.fn(() => ({ style: {} })),
  body: { appendChild: vi.fn(), removeChild: vi.fn() }
};

// Base64 encoding/decoding
global.btoa = (str) => Buffer.from(str, 'binary').toString('base64');
global.atob = (str) => Buffer.from(str, 'base64').toString('binary');
global.console = console;

// Import SecurityStatic
let SecurityStatic;

beforeEach(async () => {
  // Reset all mocks and storage
  vi.clearAllMocks();
  global.sessionStorage.clear();
  global.localStorage.clear();
  
  // Dynamic import der SecurityStatic Klasse
  const securityModule = await import('../scripts/security.static.js');
  SecurityStatic = securityModule.default || securityModule.SecurityStatic;
});

// ===== TEST KATEGORIE 1: INITIALISIERUNG (4 Tests) =====
describe('SecurityStatic v2.1 - Initialisierung', () => {
  it('1.1 sollte erfolgreich initialisieren', () => {
    const security = new SecurityStatic();
    expect(security).toBeDefined();
    expect(security.version).toBe('2.1');
  });

  it('1.2 sollte Standardkonfiguration laden', () => {
    const security = new SecurityStatic();
    expect(security.salt).toBeDefined();
    expect(security.sessionTimeout).toBeGreaterThan(0);
  });

  it('1.3 sollte benutzerdefinierte Konfiguration akzeptieren', () => {
    const config = { salt: 'custom_salt', sessionTimeout: 5000 };
    const security = new SecurityStatic(config);
    expect(security.salt).toBe('custom_salt');
    expect(security.sessionTimeout).toBe(5000);
  });

  it('1.4 sollte Logging korrekt initialisieren', () => {
    const security = new SecurityStatic({ enableLogging: true });
    expect(security.enableLogging).toBe(true);
  });
});

// ===== TEST KATEGORIE 2: HASHING (6 Tests) =====
describe('SecurityStatic v2.1 - Hashing', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ salt: DETERMINISTIC_SALT });
  });

  it('2.1 sollte deterministischen Hash erstellen', async () => {
    const input = 'test_input';
    const hash1 = await security.createHash(input);
    const hash2 = await security.createHash(input);
    
    if (TEST_MODE) {
      expect(hash1).toBe(hash2); // Deterministisch im Testmodus
    }
    expect(hash1).toBeDefined();
    expect(typeof hash1).toBe('string');
  });

  it('2.2 sollte verschiedene Eingaben unterschiedlich hashen', async () => {
    const hash1 = await security.createHash('input1');
    const hash2 = await security.createHash('input2');
    expect(hash1).not.toBe(hash2);
  });

  it('2.3 sollte Hex-Format unterst√ºtzen', async () => {
    const hash = await security.createSecureHash('test', 'hex');
    expect(hash).toMatch(/^[0-9a-fA-F]+$/);
  });

  it('2.4 sollte Base64-Format unterst√ºtzen', async () => {
    const hash = await security.createSecureHash('test', 'base64');
    expect(hash).toMatch(/^[A-Za-z0-9+/=]+$/);
  });

  it('2.5 sollte leere Eingaben verarbeiten', async () => {
    const hash = await security.createHash('');
    expect(hash).toBeDefined();
    expect(hash.length).toBeGreaterThan(0);
  });

  it('2.6 sollte Unicode-Zeichen korrekt hashen', async () => {
    const hash = await security.createHash('ÊµãËØïüöÄ√§√∂√º');
    expect(hash).toBeDefined();
    expect(typeof hash).toBe('string');
  });
});

// ===== TEST KATEGORIE 3: HMAC (4 Tests) =====
describe('SecurityStatic v2.1 - HMAC', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ salt: DETERMINISTIC_SALT });
  });

  it('3.1 sollte HMAC-SHA256 erstellen', async () => {
    const message = 'test_message';
    const key = 'secret_key';
    const hmac = await security.hmacSHA256(message, key);
    
    expect(hmac).toBeDefined();
    expect(typeof hmac).toBe('string');
  });

  it('3.2 sollte deterministische HMAC-Werte liefern', async () => {
    const message = 'consistent_message';
    const key = 'consistent_key';
    const hmac1 = await security.hmacSHA256(message, key);
    const hmac2 = await security.hmacSHA256(message, key);
    
    if (TEST_MODE) {
      expect(hmac1).toBe(hmac2);
    }
  });

  it('3.3 sollte verschiedene Keys verschiedene HMACs erzeugen', async () => {
    const message = 'same_message';
    const hmac1 = await security.hmacSHA256(message, 'key1');
    const hmac2 = await security.hmacSHA256(message, 'key2');
    
    expect(hmac1).not.toBe(hmac2);
  });

  it('3.4 sollte HMAC-Verifikation unterst√ºtzen', async () => {
    const message = 'verify_message';
    const key = 'verify_key';
    const hmac = await security.hmacSHA256(message, key);
    
    const isValid = await security.verifyHMAC(message, key, hmac);
    expect(isValid).toBe(true);
  });
});

// ===== TEST KATEGORIE 4: ANSWER-FLOW (4 Tests) =====
describe('SecurityStatic v2.1 - Answer-Flow', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ salt: DETERMINISTIC_SALT });
  });

  it('4.1 sollte Antworten korrekt hashen', async () => {
    const answer = 'correct_answer';
    const questionId = 'q1';
    const hash = await security.hashAnswer(answer, questionId);
    
    expect(hash).toBeDefined();
    expect(typeof hash).toBe('string');
  });

  it('4.2 sollte Antworten verifizieren', async () => {
    const answer = 'test_answer';
    const questionId = 'q2';
    const hash = await security.hashAnswer(answer, questionId);
    
    const isValid = await security.verifyAnswer(answer, questionId, hash);
    expect(isValid).toBe(true);
  });

  it('4.3 sollte falsche Antworten ablehnen', async () => {
    const correctAnswer = 'correct';
    const wrongAnswer = 'wrong';
    const questionId = 'q3';
    const hash = await security.hashAnswer(correctAnswer, questionId);
    
    const isValid = await security.verifyAnswer(wrongAnswer, questionId, hash);
    expect(isValid).toBe(false);
  });

  it('4.4 sollte Case-Insensitive Verifikation unterst√ºtzen', async () => {
    const answer = 'Test Answer';
    const questionId = 'q4';
    const hash = await security.hashAnswer(answer.toLowerCase(), questionId);
    
    const isValid = await security.verifyAnswer(answer.toUpperCase(), questionId, hash, true);
    expect(isValid).toBe(true);
  });
});

// ===== TEST KATEGORIE 5: SESSION-MANAGEMENT (4 Tests) =====
describe('SecurityStatic v2.1 - Session-Management', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ 
      salt: DETERMINISTIC_SALT,
      sessionTimeout: 1000 
    });
  });

  it('5.1 sollte Session erstellen', () => {
    const sessionId = security.createSession();
    expect(sessionId).toBeDefined();
    expect(typeof sessionId).toBe('string');
    expect(sessionId.length).toBeGreaterThan(10);
  });

  it('5.2 sollte Session validieren', () => {
    const sessionId = security.createSession();
    const isValid = security.validateSession(sessionId);
    expect(isValid).toBe(true);
  });

  it('5.3 sollte Session-Timeout respektieren', async () => {
    const sessionId = security.createSession();
    
    // Simulate timeout
    await new Promise(resolve => setTimeout(resolve, 1100));
    
    const isValid = security.validateSession(sessionId);
    expect(isValid).toBe(false);
  });

  it('5.4 sollte Session-Daten speichern und abrufen', () => {
    const sessionId = security.createSession();
    const testData = { userId: 123, role: 'user' };
    
    security.setSessionData(sessionId, testData);
    const retrievedData = security.getSessionData(sessionId);
    
    expect(retrievedData).toEqual(testData);
  });
});

// ===== TEST KATEGORIE 6: RATE-LIMITING (3 Tests) =====
describe('SecurityStatic v2.1 - Rate-Limiting', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ 
      salt: DETERMINISTIC_SALT,
      maxAttempts: 3,
      rateLimitWindow: 1000
    });
  });

  it('6.1 sollte Rate-Limiting aktivieren', () => {
    const result1 = security.checkRateLimit('test_user');
    const result2 = security.checkRateLimit('test_user');
    const result3 = security.checkRateLimit('test_user');
    
    expect(result1).toBe(true);
    expect(result2).toBe(true);
    expect(result3).toBe(true);
  });

  it('6.2 sollte Rate-Limit √ºberschreitung erkennen', () => {
    for (let i = 0; i < 3; i++) {
      security.checkRateLimit('blocked_user');
    }
    
    const result = security.checkRateLimit('blocked_user');
    expect(result).toBe(false);
  });

  it('6.3 sollte Rate-Limit nach Timeout zur√ºcksetzen', async () => {
    for (let i = 0; i < 3; i++) {
      security.checkRateLimit('timeout_user');
    }
    
    // Simulate timeout
    await new Promise(resolve => setTimeout(resolve, 1100));
    
    const result = security.checkRateLimit('timeout_user');
    expect(result).toBe(true);
  });
});

// ===== TEST KATEGORIE 7: UTILITIES (3 Tests) =====
describe('SecurityStatic v2.1 - Utilities', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ salt: DETERMINISTIC_SALT });
  });

  it('7.1 sollte sichere IDs generieren', () => {
    const id1 = security.generateSecureId();
    const id2 = security.generateSecureId();
    
    expect(id1).toBeDefined();
    expect(id2).toBeDefined();
    expect(id1).not.toBe(id2);
    expect(id1.length).toBeGreaterThan(8);
  });

  it('7.2 sollte Input-Sanitization durchf√ºhren', () => {
    const maliciousInput = '<script>alert("xss")</script>';
    const sanitized = security.sanitizeInput(maliciousInput);
    
    expect(sanitized).not.toContain('<script>');
    expect(sanitized).not.toContain('alert');
  });

  it('7.3 sollte Timestamps validieren', () => {
    const validTimestamp = Date.now();
    const invalidTimestamp = 'invalid';
    
    expect(security.validateTimestamp(validTimestamp)).toBe(true);
    expect(security.validateTimestamp(invalidTimestamp)).toBe(false);
  });
});

// ===== TEST KATEGORIE 8: INTEGRATION (3 Tests) =====
describe('SecurityStatic v2.1 - Integration', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ 
      salt: DETERMINISTIC_SALT,
      enableLogging: true
    });
  });

  it('8.1 sollte kompletten Auth-Flow durchlaufen', async () => {
    // 1. Session erstellen
    const sessionId = security.createSession();
    expect(security.validateSession(sessionId)).toBe(true);
    
    // 2. Antwort hashen und verifizieren
    const answer = 'integration_test';
    const questionId = 'integration_q1';
    const hash = await security.hashAnswer(answer, questionId);
    expect(await security.verifyAnswer(answer, questionId, hash)).toBe(true);
    
    // 3. Rate-Limiting testen
    expect(security.checkRateLimit('integration_user')).toBe(true);
  });

  it('8.2 sollte Error-Handling demonstrieren', async () => {
    try {
      await security.createHash(null);
    } catch (error) {
      expect(error).toBeDefined();
    }
  });

  it('8.3 sollte Performance-Benchmarking unterst√ºtzen', async () => {
    const startTime = Date.now();
    
    for (let i = 0; i < 10; i++) {
      await security.createHash(`performance_test_${i}`);
    }
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    expect(duration).toBeLessThan(5000); // Sollte unter 5 Sekunden sein
  });
});

// ===== BONUS TESTS F√úR V2.1 FEATURES =====
describe('SecurityStatic v2.1 - Enhanced Features', () => {
  let security;

  beforeEach(() => {
    security = new SecurityStatic({ salt: DETERMINISTIC_SALT });
  });

  it('Bonus 1: sollte erweiterte Kryptografie unterst√ºtzen', async () => {
    const data = 'advanced_crypto_test';
    const result = await security.advancedEncryption(data);
    expect(result).toBeDefined();
  });

  it('Bonus 2: sollte Audit-Logging aktivieren', () => {
    const auditEntry = security.createAuditLog('test_action', { user: 'test_user' });
    expect(auditEntry).toBeDefined();
    expect(auditEntry.action).toBe('test_action');
  });

  it('Bonus 3: sollte Multi-Factor-Authentication vorbereiten', async () => {
    const mfaToken = await security.generateMFAToken('user123');
    expect(mfaToken).toBeDefined();
    expect(typeof mfaToken).toBe('string');
  });
});